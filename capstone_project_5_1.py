# -*- coding: utf-8 -*-
"""Capstone Project 5.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SKjQ3s3S5GCecR73YQmyVYp-w_zpWeS4

# 5.1

## Set up
"""

!pip install openai==0.28 requests python-dotenv

import os
from google.colab import userdata
from datetime import datetime, date
from zoneinfo import ZoneInfo
import requests
import re
import json

# Read from Colab Secrets
os.environ["OPENAI_API_KEY"] = userdata.get("OPENAI")
os.environ['WEATHER_API'] = userdata.get("WEATHER_API")

"""## Calling Weather API"""

def get_weather(location):
    try:
        url = f"http://api.weatherapi.com/v1/current.json"
        params = {
            "key": os.environ['WEATHER_API'],
            "q": location,
            "aqi": "no"
        }
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raise exception for bad status codes
        return response.json()
    except requests.exceptions.RequestException as e:
        raise Exception(f"Weather API error: {str(e)}")

def _parse_iso_date(d: str) -> date:
    try:
        return datetime.strptime(d, "%Y-%m-%d").date()
    except ValueError:
        raise ValueError("date must be YYYY-MM-DD (e.g., 2026-01-16)")

def get_weather_forecast(location: str, target_date: str) -> dict:
    d = _parse_iso_date(target_date)
    today = date.today()
    delta = (d - today).days

    if delta < 0:
        raise ValueError("date is in the past (use history endpoint if you need past weather).")
    if delta <= 14:
        endpoint = "forecast.json"
    elif delta <= 300:
        endpoint = "future.json"
    else:
        raise ValueError("date too far out (WeatherAPI future supports up to ~300 days).")

    url = f"http://api.weatherapi.com/v1/{endpoint}"
    params = {
        "key": os.environ["WEATHER_API"],
        "q": location,
        "dt": target_date,
        "aqi": "no",
        "alerts": "no",
    }
    r = requests.get(url, params=params, timeout=15)
    r.raise_for_status()
    return r.json()

if __name__ == "__main__":
    try:
        weather_data = get_weather("London")
        print(f"Weather in {weather_data['location']['name']}:")
        print(f"Temperature: {weather_data['current']['temp_c']}°C")
        print(f"Condition: {weather_data['current']['condition']['text']}")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    try:
        weather_data = get_weather_forecast("London", "2026-01-23")
        loc = weather_data["location"]["name"]
        fd = weather_data["forecast"]["forecastday"][0]
        day = fd["day"]
        print(f"Forecast for {loc} on {fd['date']}: {day['condition']['text']}. ")
        print(f"Temp {day['mintemp_c']}°C–{day['maxtemp_c']}°C. ")
        print(f"Chance of rain: {day.get('daily_chance_of_rain', 'N/A')}%.")
    except Exception as e:
        print(f"Error: {e}")

"""## Adding OpenAI Function"""

import openai

openai.api_key = os.environ["OPENAI_API_KEY"]

functions = [
    {
        "name": "get_weather",
        "description": "Get current weather for a location",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {"type": "string", "description": "City name or location"}
            },
            "required": ["location"],
        },
    },
    {
        "name": "get_weather_forecast",
        "description": "Get weather for a location on a specific date (YYYY-MM-DD).",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {"type": "string", "description": "City name or location"},
                "date": {
                    "type": "string",
                    "description": "Target date in YYYY-MM-DD format (e.g., 2026-01-16)"
                },
            },
            "required": ["location", "date"],
        },
    },
]

if __name__ == "__main__":
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": "What's the weather like in Tokyo on Jan 17th 2026?"}],
            functions=functions,
            function_call="auto"
        )
        print("OpenAI Response:")
        print(response.choices[0].message.function_call)
    except Exception as e:
        print(f"Error: {e}")

"""## Implement weather agent"""

def weather_agent(user_query: str) -> str:
    try:
        today_sg = datetime.now(ZoneInfo("Asia/Singapore")).date().isoformat()

        system_prompt = (
            "You are a weather assistant.\n"
            f"Anchor date (today) is {today_sg} in Asia/Singapore timezone.\n"
            "If the user asks about a specific date, call get_weather_forecast.\n"
            "For relative dates (tomorrow, next Monday, next weekend), "
            "convert them to YYYY-MM-DD using the anchor date before calling the function.\n"
            "NEVER pass words like 'tomorrow' as the date argument.\n"
            "If the user asks about current weather, call get_weather.\n"
            "After answering the user's query, add:\n"
            "1) One line suggesting suitable activities.\n"
            "2) One line suggesting what to wear.\n"
           "Final Output Format:"
           "Answer user query \n"
           "Suggested activities \n"
           "Suggested outfit"
        )

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_query},
        ]

        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=messages,
            functions=functions,
            function_call="auto",
        )

        msg = resp["choices"][0]["message"]

        if "function_call" not in msg:
            return msg.get("content", "")

        fc = msg["function_call"]
        fn_name = fc["name"]
        args = json.loads(fc.get("arguments", "{}"))

        if fn_name == "get_weather":
            tool_result = get_weather(args["location"])
        elif fn_name == "get_weather_forecast":
            tool_result = get_weather_forecast(args["location"], args["date"])
        else:
            return f"Unknown function: {fn_name}"

        messages.append(msg)
        messages.append(
            {
                "role": "function",
                "name": fn_name,
                "content": json.dumps(tool_result),
            }
        )

        final = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=messages,
        )

        return final["choices"][0]["message"].get("content", "")

    except Exception as e:
        return f"Error: {str(e)}"

if __name__ == "__main__":
    test_queries = [
        "What's the weather like in Singapore?",
        "Is it raining in London right now?",
        "Tell me the temperature in New York"
    ]

    for query in test_queries:
        print(f"\nQuery: {query}")
        print(f"Response: {weather_agent(query)}")

if __name__ == "__main__":
    test_queries = [
        "What's the weather like in Clementi, Singapore now?",
        "what's the weather like in downtown Singapore Jan 25th 2026?",
        "What's the feel like temperature and humidity in Clementi Singapore on Jan 15th 2026?"
    ]

    for query in test_queries:
        print(f"\nQuery: {query}")
        print(f"Response: {weather_agent(query)}")

"""# 5.2

## Set Up
"""

import sqlite3
def setup_database():
    conn = sqlite3.connect('company.db')
    c = conn.cursor()

    # Create sample tables
    c.execute('''
        CREATE TABLE IF NOT EXISTS employees (
            id INTEGER PRIMARY KEY,
            name TEXT,
            department TEXT,
            salary REAL,
            manager_id INTEGER
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS departments (
            id INTEGER PRIMARY KEY,
            name TEXT,
            budget REAL
        )
    ''')

    # Insert sample data
    c.execute("INSERT OR IGNORE INTO employees VALUES (1, 'John Doe', 'Engineering', 75000, NULL)")
    c.execute("INSERT OR IGNORE INTO employees VALUES (2, 'Karen Bishop', 'Engineering', 77000, 1)")
    c.execute("INSERT OR IGNORE INTO employees VALUES (3, 'Jane Smith', 'Marketing', 65000, NULL)")
    c.execute("INSERT OR IGNORE INTO employees VALUES (4, 'Doris Freeman', 'Marketing', 55000, 3)")
    c.execute("INSERT OR IGNORE INTO departments VALUES (1, 'Engineering', 1000000)")
    c.execute("INSERT OR IGNORE INTO departments VALUES (2, 'Marketing', 500000)")

    conn.commit()
    conn.close()

if __name__ == "__main__":
    setup_database()

    # Verify the setup
    conn = sqlite3.connect('company.db')
    c = conn.cursor()

    print("Employees table:")
    c.execute("SELECT * FROM employees")
    print(c.fetchall())

    print("\nDepartments table:")
    c.execute("SELECT * FROM departments")
    print(c.fetchall())

    conn.close()

"""## SQL Generator"""

def get_schema():
    return """
    Table: employees
    Columns:
    - id (INTEGER PRIMARY KEY)
    - name (TEXT)
    - department (TEXT)
    - salary (REAL)
    - manager_id (INTEGER)

    Table: departments
    Columns:
    - id (INTEGER PRIMARY KEY)
    - name (TEXT)
    - budget (REAL)
    """

def generate_query_plan(question: str) -> dict:
    resp = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": (
                    "You are a data analyst translating questions into SQL logic.\n"
                    "Given the database schema, output ONLY valid JSON with the following keys:\n"
                    "intent, tables, joins, filters, select_fields, grouping, ordering, limit, assumptions.\n"
                    "Do NOT output SQL here.\n"
                    f"Schema:\n{get_schema()}"
                ),
            },
            {"role": "user", "content": question},
        ],
    )
    content = resp["choices"][0]["message"]["content"].strip()
    return json.loads(content)

def generate_sql_from_plan(plan: dict) -> str:
    resp = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "system",
                "content": (
                    "You are a SQL expert. Use the schema and the provided query plan.\n"
                    "Return ONLY the SQL query. No markdown, no explanation.\n"
                    "SQL must be compatible with SQLite.\n"
                    f"Schema:\n{get_schema()}"
                ),
            },
            {
                "role": "user",
                "content": (
                    "Query plan (JSON):\n"
                    f"{json.dumps(plan, indent=2)}\n\n"
                    "Generate the SQL."
                ),
            },
        ],
    )
    sql = resp["choices"][0]["message"]["content"].strip()
    return sql.replace("```sql", "").replace("```", "").strip()

if __name__ == "__main__":
    test_questions = [
        "List all employees",
        "Show departments with budgets over 750000",
        "Calculate average salary for each department",
        "Find out who has higher salary than the manager"
    ]

    for question in test_questions:
        print(f"\nQuestion: {question}")
        print(f"Generated SQL: {generate_query_plan(question)}")

if __name__ == "__main__":
    test_questions = [
        "List all employees",
        "Show departments with budgets over 750000",
        "Calculate average salary for each department",
        "Find out who has higher salary than the manager"
    ]

    for question in test_questions:
        print(f"\nQuestion: {question}")
        print(f"Generated SQL: {generate_sql_from_plan(generate_query_plan(question))}")

"""## Query Execution"""

def validate_sql(sql):
    # Basic safety checks
    sql_lower = sql.lower()
    if any(word in sql_lower for word in ['drop', 'delete', 'update', 'insert']):
        raise ValueError("Only SELECT queries are allowed")
    return sql

def execute_query(sql):
    sql = validate_sql(sql)
    conn = sqlite3.connect('company.db')
    try:
        cursor = conn.cursor()
        cursor.execute(sql)
        rows = cursor.fetchall()
        headers = [desc[0] for desc in cursor.description] if cursor.description else []
        return headers, rows
    except Exception as e:
        return [], f"Error: {str(e)}"
    finally:
        conn.close()

def pretty_table(headers, rows, max_width=40):
    if isinstance(rows, str):
        return rows
    if not rows:
        return "No results found"

    def norm(x):
        s = "" if x is None else str(x)
        return s if len(s) <= max_width else s[:max_width-3] + "..."

    # Convert to strings
    str_headers = [norm(h) for h in headers] if headers else [f"col{i+1}" for i in range(len(rows[0]))]
    str_rows = [[norm(v) for v in row] for row in rows]

    # Column widths
    cols = list(zip(*([str_headers] + str_rows)))
    widths = [max(len(x) for x in col) for col in cols]

    def fmt_row(r):
        return " | ".join(val.ljust(w) for val, w in zip(r, widths))

    sep = "-+-".join("-" * w for w in widths)

    out = [fmt_row(str_headers), sep]
    out += [fmt_row(r) for r in str_rows]
    return "\n".join(out)

if __name__ == "__main__":
    test_sql = [
        "SELECT * FROM employees WHERE salary > 70000",
        "SELECT d.name, COUNT(e.id) FROM departments d LEFT JOIN employees e ON d.name = e.department GROUP BY d.name"
    ]

    for sql in test_sql:
        print(f"\nExecuting SQL: {sql}")
        print(f"Results: {execute_query(sql)}")

"""## Complete SQL Agent"""

def query_agent(question):
    try:
        # 1) Generate human-style plan
        plan = generate_query_plan(question)

        # 2) Generate SQL from plan
        sql = generate_sql_from_plan(plan)
        print(f"Generated SQL: {sql}\n")

        # 3) Execute
        headers, rows = execute_query(sql)

        # 4) Pretty output
        return pretty_table(headers, rows)

    except Exception as e:
        return f"Error: {str(e)}"

if __name__ == "__main__":
    test_questions = [
        "What is the average salary in each department?",
        "Which department has the highest budget?",
        "List all employees earning more than 70000",
        "DROP TABLE employees",
        "Calculate average salary for each department",
        "Find out who has higher salary than the manager"
    ]

    for question in test_questions:
        print(f"\nQuestion: {question}")
        print(f"Answer: {query_agent(question)}")

"""# 5.3

## Set Up
"""

def setup_database():
    conn = sqlite3.connect('events.db')
    c = conn.cursor()

    c.execute('''
        CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY,
            name TEXT,
            type TEXT,  -- 'indoor' or 'outdoor'
            description TEXT,
            location TEXT,
            date TEXT
        )
    ''')

    # Sample events
    events = [
        ('Summer Concert', 'outdoor', 'Live music in the park', 'Central Park', '2026-01-17'),
        ('Art Exhibition', 'indoor', 'Modern art showcase', 'City Gallery', '2026-01-18'),
        ('Food Festival', 'outdoor', 'International cuisine', 'Waterfront', '2026-01-24'),
        ('Theater Show', 'indoor', 'Classical drama', 'Grand Theater', '2026-01-25')
    ]

    c.executemany('INSERT OR IGNORE INTO events (name, type, description, location, date) VALUES (?,?,?,?,?)', events)
    conn.commit()
    conn.close()

if __name__ == "__main__":
    setup_database()

"""## Implementation"""

from datetime import datetime, timedelta, date

def validate_date_yyyy_mm_dd(date_str: str) -> str:
    try:
        datetime.strptime(date_str, "%Y-%m-%d")
        return date_str
    except ValueError:
        raise ValueError("Invalid date format. Use YYYY-MM-DD (e.g., 2026-01-16).")

def resolve_next_weekend(anchor: date | None = None) -> str:
    if anchor is None:
        anchor = date.today()
    # Saturday = 5 (Mon=0)
    days_until_sat = (5 - anchor.weekday()) % 7
    if days_until_sat == 0:
        days_until_sat = 7  # "next" weekend
    return (anchor + timedelta(days=days_until_sat)).isoformat()

class WeatherAgent:
    def __init__(self, api_key):
        self.api_key = api_key

    def get_weather(self, location: str, target_date: str) -> dict:
        d = _parse_iso_date(target_date)
        today = date.today()

        try:
            if d == today:
                data = get_weather(location)  # current.json
            else:
                data = get_weather_forecast(location, target_date)  # forecast.json / future.json

        except requests.exceptions.HTTPError as e:
            # Try to parse WeatherAPI error JSON for a clean message
            msg = None
            try:
                if e.response is not None:
                    err_json = e.response.json()
                    if isinstance(err_json, dict) and "error" in err_json:
                        msg = err_json["error"].get("message")
            except Exception:
                pass

            if not msg:
                # Fallback if response body isn't JSON
                msg = f"Weather API request failed (HTTP {getattr(e.response, 'status_code', 'unknown')})."
            raise ValueError(f"Invalid location or weather query: {msg}")

        except Exception as e:
            # Covers past date, out-of-range date, network errors, etc.
            raise ValueError(f"Invalid location or weather query: {str(e)}")

        # If API returned an error object without raising HTTPError
        if isinstance(data, dict) and "error" in data:
            msg = data["error"].get("message", "Unknown weather API error")
            raise ValueError(f"Invalid location or weather query: {msg}")

        return self.summarize_weather(data)

    @staticmethod
    def summarize_weather(weather_data: dict) -> dict:
        """
        Normalize both current.json and forecast.json outputs
        into a single, clean structure.
        """
        summary = {
            "condition": None,
            "temp_c": None,
            "min_c": None,
            "max_c": None,
            "chance_of_rain": None,
            "is_bad_outdoor": False,
        }

        # Forecast path
        if "forecast" in weather_data and weather_data["forecast"].get("forecastday"):
            day = weather_data["forecast"]["forecastday"][0]["day"]
            summary["condition"] = day["condition"]["text"]
            summary["min_c"] = day["mintemp_c"]
            summary["max_c"] = day["maxtemp_c"]
            summary["chance_of_rain"] = day["daily_chance_of_rain"]

            cond = summary["condition"].lower()
            rain = int(summary["chance_of_rain"] or 0)
            summary["is_bad_outdoor"] = rain >= 60 or "rain" in cond or "thunder" in cond

        # Current path
        elif "current" in weather_data:
            cur = weather_data["current"]
            summary["condition"] = cur["condition"]["text"]
            summary["temp_c"] = cur["temp_c"]

            cond = summary["condition"].lower()
            summary["is_bad_outdoor"] = "rain" in cond or "thunder" in cond

        return summary

class EventAgent:
    def __init__(self, db_path="events.db"):
        self.db_path = db_path

    def get_events(self, date_str: str, event_type: str | None = None):
        validate_date_yyyy_mm_dd(date_str)

        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        try:
            if event_type:
                c.execute("SELECT * FROM events WHERE date = ? AND type = ?", (date_str, event_type))
            else:
                c.execute("SELECT * FROM events WHERE date = ?", (date_str,))
            return c.fetchall()
        except sqlite3.Error as e:
            raise Exception(f"Database error: {str(e)}")
        finally:
            conn.close()

class RecommendationAgent:
    def __init__(self, openai_api_key: str):
        openai.api_key = openai_api_key

    def generate_recommendation(self, weather_summary: dict, events: list[dict], party_size: int) -> str:
        if not events:
            return "No events found for this date."

        # Minimal deterministic “pre-hint” to reduce LLM randomness
        context = {
            "weather": weather_summary,
            "party_size": party_size,
            "events": events,
        }

        system = (
            "You are an event recommender.\n"
            "Use the provided weather, party size, and events list.\n"
            "Start your response with one-line summary of the weather condition, make sure to include the temperature of the day and chance of rain. \n"
            "Rules:\n"
            "- If weather.is_bad_outdoor is true, prioritize indoor events.\n"
            "- If only one event is available, do not repeat. \n"
            "- For party_size >= 5, prefer group-friendly activities (festivals, food events, outdoor markets, concerts).\n"
            "- For party_size <= 2, intimate activities (theater, exhibitions) are fine.\n"
            "Output format:\n"
            "weather summary \n"
            "suggested activity and suggested dress code"
            "Be friendly and slightly quirky."
        )

        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system},
                {"role": "user", "content": "Here is the context JSON:\n" + json.dumps(context, ensure_ascii=False, indent=2)},
            ],
        )
        return resp["choices"][0]["message"]["content"].strip()

class CoordinatorAgent:
    def __init__(self, weather_api_key, openai_api_key):
        self.weather_agent = WeatherAgent(weather_api_key)   # should call your forecast function inside
        self.event_agent = EventAgent()
        self.recommendation_agent = RecommendationAgent(openai_api_key)

    def _interpret_date(self, date_input: str) -> str:
        s = (date_input or "").strip().lower()
        if s in {"next weekend", "nextweekend"}:
            return resolve_next_weekend()
        return validate_date_yyyy_mm_dd(date_input)

    def _choose_event_type_filter(self, weather_summary: dict) -> str | None:
        return "indoor" if weather_summary.get("is_bad_outdoor") else None

    def _events_to_dicts(self, events):
        out = []
        for e in events:
            out.append({
                "id": e[0],
                "name": e[1],
                "type": e[2],
                "description": e[3],
                "location": e[4],
                "date": e[5],
            })
        return out

    def get_recommendations(self, location, date_input, party_size=2):
        try:
            # Basic input validation
            if not location or not location.strip():
                return "Error: Please provide a location."
            if not isinstance(party_size, int) or party_size <= 0:
                return "Error: party_size must be a positive integer."

            target_date = self._interpret_date(date_input)

            # Weather: use your forecast function (even if WeatherAgent class originally used current.json)
            print(f"\nFetching weather data for {location} on {target_date}...")
            weather_summary = self.weather_agent.get_weather(location, target_date)

            # WeatherAPI invalid location commonly returns {"error": {...}}
            if isinstance(weather_data, dict) and "error" in weather_data:
                msg = weather_data["error"].get("message", "Unknown error")
                return f"Error: Invalid location for weather API. {msg}"

            # Events: optionally filter indoor if weather is bad
            print("Fetching events...")
            event_type = self._choose_event_type_filter(weather_summary)
            events = self.event_agent.get_events(target_date, event_type=event_type)

            # If filtering leads to empty list, fallback to all events
            if not events and event_type is not None:
                events = self.event_agent.get_events(target_date, event_type=None)

            if not events:
                return f"No events found for {target_date}."

            events_dicts = self._events_to_dicts(events)

            # Recommendations: include party size in the context (modify RecommendationAgent accordingly)
            print("Generating recommendations...")
            recommendations = self.recommendation_agent.generate_recommendation(
                weather_summary=weather_summary,
                events=events_dicts,
                party_size=party_size
            )
            return recommendations

        except ValueError as ve:
            return f"Error: {str(ve)}"
        except Exception as e:
            return f"Error: {str(e)}"

if __name__ == "__main__":
    # Make sure the events DB exists
    setup_database()

    # Test cases: (date_input, location)
    test_cases = [
        # Future date using forecast
        ("next weekend", "Singapore"),

        # Explicit future date (adjust if needed)
        ((date.today() + timedelta(days=3)).isoformat(), "Singapore"),

        # Invalid location
        ("next weekend", "S1ngap0re???"),

        # Past date (should trigger weather forecast error)
        ("2025-07-15", "Singapore"),

        # No events on this date
        ("2026-01-23", "Singapore"),

        # this weekend
        ("2026-01-18", "Singapore"),

        # no location
        ("2026-01-18", "")
    ]

    coordinator = CoordinatorAgent(
        os.environ["WEATHER_API"],
        os.environ["OPENAI_API_KEY"]
    )

    for test_date, test_location in test_cases:
        print(f"\n{'='*60}")
        print(f"Getting recommendations for {test_location} on {test_date}")
        print(f"{'='*60}")
        print(coordinator.get_recommendations(test_location, test_date))

